# python notes

## virtual env

    - When you have two projects, and want same package with different versions, then venv helps.
    - It creates the virtaul env, where you can install the packages with that specific verison and you can use that directly into your code.
    - command to create a venv :
      - You can do that using ctrl+shift+P -> create virtual env -> select python version.
      - In terminal
        - `python -m venv .venv` & `source .venv/bin/activate` [Remember to put exact path what you've named your venv folder]
          - To check if venv is activated:
            - `which python` || `which pip`
        - And to deactivate `deactivate`
        - And it should be active:
          - If it doesn't show any .venv on terminal you can kill that terminal and open new.
          - You can view that right hand side of your vscode right below to your terminal written 3.12.3 (.venv) if its there, then you can continue to install the packages.
          - If you can't then click on that version and then select the .venv.
    - Same for this we have anaconda for managing python distributions and virtual env on your machine
    - Very popular, in Data Science.

## Packages

    - pip install is used to install the dependencies.
    - To upgrade the pip inside venv
      - `pip install --upgrade pip`

## Python inner working

    - hello.py (program file) => byte code (generated by python, mostly hidden) => fetched by ->  python virtual machine

    1. Compile to Byte Code:
       1. What is byte code
             1. A low-level, intermediate code that is generated when source code (human-readable programming language) is compiled.
       2. Low level code -> [ programming languages with little to no abstraction from a computer's physical hardware, operating very close to the processor ]
       3. Platfrom independent (Cloud, any OS)
       4. Byte code runs faster. (comparatively to script it runs faster)
       5. .pyc is compiled python (frozen binaries) [ They act as a cache, saving time by skipping the recompilation of code from .py to bytecode. ]
       6. __pycache__ => importance as python. learn more about this
          1. hello.cpython-312.pyc
             1. source change : It uses some diffing algo, it watches the old now and compare with new code and change only neccessary fields.
             2. cpython-312 : is python version
             3. .pyc : is frozen binaries
          2. This .pyc only works for imported files.
          3. Not for top level files (no imported dependencies)
    2. Python VM
       1. Code loop to iterate byte code
       2. It's Run Time Engine
       3. Also known as python interpreter.
    3. Byte Code is NOT machine code
       1. Machine code is direct instruction to your chip/hardware (intel, apple)
       2. Byte code is Python specific interpretation.
          1. You can't run this byte code on JAVA VM.
       3. cpython (standard implementation), jython, IronPython, Stackless, PyPy

##

## strings

    - You can use both "name" & 'name'

## Identation is important in python

    - other programming languages use {} python use identation
      ```js
      - if score > 90
        - print("A grade")
      - else
        - print ("B grade")
      ```

    - In PEP8
      - Using 4 spaces for indentation (not tabs)
      - Naming conventions like user_name not userName
      - Where to put spaces around operators

## mutable & immutable

- In python eveything is object

- Mutable mean you can change the object
- Immutable mean you can't change the object

- In memory the reference is not the variable, it's value which is stored, and if that value not pointed to any varaible then python has automatic garbage collection to remove that value from memory.

What does that mean?

- In Python, variables do not store values; they store references to objects in memory.

- The object (value) lives in memory independently of the variable name.

- Multiple variables can reference the same object.

- Immutability means the object itself cannot change (e.g., int, str, tuple).
- When you “change” an immutable value, Python creates a new object.

- Mutability means the object can change in place (e.g., list, dict, set).
- Reassigning a variable just changes what it references, not the object.

- Python uses reference counting to track how many references an object has.
- If an object’s reference count becomes zero, it becomes eligible for garbage collection.
- Garbage collection frees memory for objects no longer referenced by any variable.
- Memory has datatype | variable doesn't get assigned my datatype
- numbers and strings has delay in garbage collection.

## copy (slicing)

```ts
h1 = [1,2,3]

h2 = h1[:] // this mean start from 0 index and end at last (This is copy of h1)

// so when you change any value from h1

h1[0] = 88

// h2 never changes as it was copy not same reference.

// And mutable like lists, dict, set etc

h3 = [1,2,3]
h4 = [1,2,3]

// The above two variables hold same values, but the reference is different

// if you do

h3 == h4 // this will give you true, cauz they have same values

// but

h3 is h4 // this gives you false, because they point to different reference types in memory or you can say two seperate objects.


```

## To open file in python 
```ts

  f = open('chai.py') // You don't need to iter(f) this, because it already iterated behind or you can say interable object. You can check this iter(f) is f => this will give you True

  // But this is not same for list, you need to use iter()

  f.readline()

  f.__next__()

  // Memory iter() always refer to starting point of referrence.

```

## Scope
- Scope mean: What variables do I have access to?
  - 1. Start with local
  - 2. Parent local?
  - 3. Global
  - 4. Built in python functions

```python

total = 0
def count():
  global total
  total += 1
  return total

count()
count()
print(count())

```

// another way to do

```python

total = 0
def count(total):
  total += 1
  return total

print(count(count(count(total))))

```

=> nonLocal

```python

def outer():
  x="lcoal"
  def inner():
    nonlocal x
    x = "nonLocal"
    print("inner: ", x)
  inner()
  print("outer: ", x)

outer()


```

## requirements.txt

=> Here you can specify the packages you've installed so when other developers work on your project on their machine they don't need to install one by one package manually

1. To create that :
   `pip freeze > requirements.txt`

2. To install that :
   `pip install -r requirements.txt`


## Modules & Package

-> Modules mean files that ends with .py
    You can import those file into your main.py using `import utility`

-> Package mean folder 
    You can import that file under package using `import folders_name.file_name`
    eg: `shopping.shopping_cart`

- Then you can use all the methods which are present inside module.

1. In python every file is a module
   1. Each module has a special built-in variable called:
      1. __name__
      - Its value depends on how the file is being used.
   2. So when you run any file `functions.py` 
      1. Python treats that file as the starting point of the program.
   3. So python sets:
      1. __name__ = "__main__"

2. Simple rule to remember
| How file is used | Value of `__name__` |
| ---------------- | ------------------- |
| Run directly     | `"__main__"`        |
| Imported         | `"module_name"`     |

3. Why does python do this?
   - This allows us to write code like this:
      ```python
          if __name__ == "__main__":
            print("This runs only when file is executed directly")
      ```
So:

- If you run the file → this block runs
- If you import the file → this block does NOT run

Very useful for:

1. Testing
2. Writing reusable modules
3. Avoiding unwanted execution during import



